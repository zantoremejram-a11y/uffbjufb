<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Void Explorer</title>
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-purple: #bc13fe;
            --neon-red: #ff3131;
            --bg-dark: #0a0a0c;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a0c 100%);
        }

        /* Интерфейс (UI) */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-left: 4px solid var(--neon-blue);
            backdrop-filter: blur(5px);
            min-width: 150px;
        }

        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: var(--neon-blue);
        }

        #shield-bar-container {
            width: 200px;
            height: 8px;
            background: #333;
            margin-top: 5px;
            border-radius: 4px;
            overflow: hidden;
        }

        #shield-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
            transition: width 0.3s ease;
        }

        /* Экраны меню */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            background: linear-gradient(to right, var(--neon-blue), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(188, 19, 254, 0.5);
        }

        .btn {
            padding: 15px 40px;
            font-size: 18px;
            background: transparent;
            color: white;
            border: 2px solid var(--neon-blue);
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-top: 20px;
            border-radius: 5px;
            pointer-events: auto;
        }

        .btn:hover {
            background: var(--neon-blue);
            color: black;
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .hidden {
            display: none !important;
        }

        #controls-hint {
            margin-top: 30px;
            color: #888;
            font-size: 14px;
        }

        #game-over-stats {
            margin: 20px 0;
            font-size: 24px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="stat-box">
            <div class="stat-label">Очки</div>
            <div id="score-val" class="stat-value">0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Множитель</div>
            <div id="mult-val" class="stat-value">x1.0</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Щиты</div>
            <div id="shield-bar-container">
                <div id="shield-bar"></div>
            </div>
        </div>
    </div>

    <!-- Стартовое меню -->
    <div id="start-screen" class="overlay">
        <h1>NEON VOID</h1>
        <p>Выживайте в бесконечной пустоте. Собирайте энергию, избегайте аномалий.</p>
        <button id="start-btn" class="btn">Запуск</button>
        <div id="controls-hint">
            Мышь/Касание: Перемещение корабля<br>
            Автоматическая стрельба при опасности
        </div>
    </div>

    <!-- Экран проигрыша -->
    <div id="death-screen" class="overlay hidden">
        <h1>СИСТЕМА СБОИТ</h1>
        <div id="game-over-stats">Дистанция: <span id="final-score">0</span></div>
        <button id="restart-btn" class="btn">Перезагрузка</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score-val');
    const multEl = document.getElementById('mult-val');
    const shieldBar = document.getElementById('shield-bar');
    const finalScoreEl = document.getElementById('final-score');
    
    // Экраны
    const startScreen = document.getElementById('start-screen');
    const deathScreen = document.getElementById('death-screen');
    const startBtn = document.getElementById('start-btn');
    const restartBtn = document.getElementById('restart-btn');

    // Состояние игры
    let gameState = 'MENU';
    let score = 0;
    let multiplier = 1;
    let frameCount = 0;
    let difficulty = 1;

    // Параметры игрока
    const player = {
        x: 0,
        y: 0,
        radius: 15,
        targetX: 0,
        targetY: 0,
        shield: 100,
        maxShield: 100,
        color: '#00f2ff',
        trail: []
    };

    // Массивы объектов
    let particles = [];
    let enemies = [];
    let bullets = [];
    let collectibles = [];
    let stars = [];

    // Инициализация размеров
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        player.x = canvas.width / 2;
        player.y = canvas.height / 2;
        player.targetX = player.x;
        player.targetY = player.y;
    }

    window.addEventListener('resize', resize);
    resize();

    // Обработка ввода
    const updateMouse = (e) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        player.targetX = clientX - rect.left;
        player.targetY = clientY - rect.top;
    };

    window.addEventListener('mousemove', updateMouse);
    window.addEventListener('touchmove', updateMouse);

    // Вспомогательные функции
    const random = (min, max) => Math.random() * (max - min) + min;

    class Star {
        constructor() {
            this.reset();
        }
        reset() {
            this.x = random(0, canvas.width);
            this.y = random(0, canvas.height);
            this.size = random(0.5, 2);
            this.speed = this.size * 0.5;
        }
        update() {
            this.y += this.speed * difficulty;
            if (this.y > canvas.height) {
                this.y = 0;
                this.x = random(0, canvas.width);
            }
        }
        draw() {
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    class Enemy {
        constructor(type) {
            this.type = type; // 'chaser' или 'asteroid'
            this.radius = type === 'chaser' ? 12 : random(20, 45);
            this.reset();
        }
        reset() {
            const side = Math.floor(random(0, 4));
            if (side === 0) { this.x = random(0, canvas.width); this.y = -50; }
            else if (side === 1) { this.x = canvas.width + 50; this.y = random(0, canvas.height); }
            else if (side === 2) { this.x = random(0, canvas.width); this.y = canvas.height + 50; }
            else { this.x = -50; this.y = random(0, canvas.height); }

            const angle = Math.atan2(player.y - this.y, player.x - this.x);
            const speedBase = this.type === 'chaser' ? 2 : 1;
            this.vx = Math.cos(angle) * (speedBase + difficulty);
            this.vy = Math.sin(angle) * (speedBase + difficulty);
            this.hp = this.type === 'chaser' ? 1 : 3;
            this.color = this.type === 'chaser' ? '#ff3131' : '#bc13fe';
        }
        update() {
            if (this.type === 'chaser') {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.vx += Math.cos(angle) * 0.05;
                this.vy += Math.sin(angle) * 0.05;
                // Ограничение скорости
                const mag = Math.sqrt(this.vx**2 + this.vy**2);
                const maxS = 3 + difficulty;
                if (mag > maxS) {
                    this.vx = (this.vx / mag) * maxS;
                    this.vy = (this.vy / mag) * maxS;
                }
            }
            this.x += this.vx;
            this.y += this.vy;

            // Проверка выхода за границы
            if (this.x < -100 || this.x > canvas.width + 100 || this.y < -100 || this.y > canvas.height + 100) {
                this.reset();
            }
        }
        draw() {
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            if (this.type === 'chaser') {
                // Треугольник
                const angle = Math.atan2(this.vy, this.vx);
                ctx.moveTo(this.x + Math.cos(angle) * this.radius, this.y + Math.sin(angle) * this.radius);
                ctx.lineTo(this.x + Math.cos(angle + 2.5) * this.radius, this.y + Math.sin(angle + 2.5) * this.radius);
                ctx.lineTo(this.x + Math.cos(angle - 2.5) * this.radius, this.y + Math.sin(angle - 2.5) * this.radius);
                ctx.closePath();
            } else {
                // Шестиугольник
                for (let i = 0; i < 6; i++) {
                    const a = (i / 6) * Math.PI * 2;
                    const px = this.x + Math.cos(a) * this.radius;
                    const py = this.y + Math.sin(a) * this.radius;
                    if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                }
                ctx.closePath();
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.radius = random(1, 3);
            const angle = random(0, Math.PI * 2);
            const force = random(1, 5);
            this.vx = Math.cos(angle) * force;
            this.vy = Math.sin(angle) * force;
            this.life = 1.0;
            this.decay = random(0.01, 0.03);
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    class Collectible {
        constructor() {
            this.x = random(50, canvas.width - 50);
            this.y = random(50, canvas.height - 50);
            this.radius = 8;
            this.pulse = 0;
        }
        update() {
            this.pulse += 0.1;
        }
        draw() {
            const s = this.radius + Math.sin(this.pulse) * 3;
            ctx.shadowBlur = 15;
            ctx.shadowColor = "#00f2ff";
            ctx.fillStyle = "#00f2ff";
            ctx.beginPath();
            ctx.arc(this.x, this.y, s, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    function initStars() {
        stars = [];
        for (let i = 0; i < 100; i++) stars.push(new Star());
    }

    function spawnBullet() {
        // Находим ближайшего врага
        let nearest = null;
        let minDist = 300;
        enemies.forEach(e => {
            const d = Math.hypot(e.x - player.x, e.y - player.y);
            if (d < minDist) {
                minDist = d;
                nearest = e;
            }
        });

        if (nearest) {
            const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
            bullets.push({
                x: player.x,
                y: player.y,
                vx: Math.cos(angle) * 8,
                vy: Math.sin(angle) * 8,
                life: 100
            });
        }
    }

    function resetGame() {
        score = 0;
        multiplier = 1;
        difficulty = 1;
        player.shield = 100;
        enemies = [];
        bullets = [];
        particles = [];
        collectibles = [new Collectible(), new Collectible()];
        frameCount = 0;
        updateUI();
    }

    function updateUI() {
        scoreEl.innerText = Math.floor(score);
        multEl.innerText = `x${multiplier.toFixed(1)}`;
        shieldBar.style.width = `${player.shield}%`;
        if (player.shield < 30) shieldBar.style.background = "var(--neon-red)";
        else shieldBar.style.background = "linear-gradient(90deg, var(--neon-blue), var(--neon-purple))";
    }

    function createExplosion(x, y, color) {
        for (let i = 0; i < 15; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function loop() {
        if (gameState !== 'PLAYING') return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        frameCount++;

        // Постепенное усложнение
        difficulty += 0.0001;
        if (frameCount % 600 === 0) multiplier += 0.1;

        // Фон
        stars.forEach(s => {
            s.update();
            s.draw();
        });

        // Движение игрока (плавное следование)
        player.x += (player.targetX - player.x) * 0.1;
        player.y += (player.targetY - player.y) * 0.1;

        // Хвост игрока
        player.trail.push({x: player.x, y: player.y});
        if (player.trail.length > 10) player.trail.shift();

        ctx.beginPath();
        ctx.strokeStyle = "rgba(0, 242, 255, 0.3)";
        ctx.lineWidth = 4;
        player.trail.forEach((p, i) => {
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();

        // Рисование игрока
        ctx.shadowBlur = 15;
        ctx.shadowColor = player.color;
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Стрельба
        if (frameCount % 20 === 0) spawnBullet();

        // Пули
        for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.vx;
            b.y += b.vy;
            b.life--;

            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
            ctx.fill();

            if (b.life <= 0) bullets.splice(i, 1);
        }

        // Враги
        if (enemies.length < 5 + Math.floor(difficulty * 2)) {
            enemies.push(new Enemy(Math.random() > 0.7 ? 'asteroid' : 'chaser'));
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            e.update();
            e.draw();

            // Коллизия пуля-враг
            bullets.forEach((b, bi) => {
                const dist = Math.hypot(e.x - b.x, e.y - b.y);
                if (dist < e.radius + 3) {
                    e.hp--;
                    bullets.splice(bi, 1);
                    if (e.hp <= 0) {
                        createExplosion(e.x, e.y, e.color);
                        score += (e.type === 'chaser' ? 50 : 100) * multiplier;
                        enemies.splice(i, 1);
                    }
                }
            });

            // Коллизия игрок-враг
            const distPlayer = Math.hypot(e.x - player.x, e.y - player.y);
            if (distPlayer < e.radius + player.radius) {
                player.shield -= 20;
                createExplosion(e.x, e.y, e.color);
                enemies.splice(i, 1);
                if (player.shield <= 0) {
                    gameOver();
                }
            }
        }

        // Коллекционные предметы
        for (let i = collectibles.length - 1; i >= 0; i--) {
            const c = collectibles[i];
            c.update();
            c.draw();

            const dist = Math.hypot(c.x - player.x, c.y - player.y);
            if (dist < c.radius + player.radius) {
                player.shield = Math.min(100, player.shield + 15);
                multiplier += 0.2;
                score += 200 * multiplier;
                createExplosion(c.x, c.y, "#00f2ff");
                collectibles.splice(i, 1);
                setTimeout(() => collectibles.push(new Collectible()), 3000);
            }
        }

        // Эффекты смерти/частиц
        for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            particles[i].draw();
            if (particles[i].life <= 0) particles.splice(i, 1);
        }

        updateUI();
        requestAnimationFrame(loop);
    }

    function gameOver() {
        gameState = 'DEATH';
        deathScreen.classList.remove('hidden');
        finalScoreEl.innerText = Math.floor(score);
    }

    startBtn.addEventListener('click', () => {
        startScreen.classList.add('hidden');
        gameState = 'PLAYING';
        resetGame();
        initStars();
        loop();
    });

    restartBtn.addEventListener('click', () => {
        deathScreen.classList.add('hidden');
        gameState = 'PLAYING';
        resetGame();
    });

</script>
</body>
</html>